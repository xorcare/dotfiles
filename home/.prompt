# shellcheck shell=bash
# shellcheck disable=SC2034

if [[ $COLORTERM = gnome-* && $TERM = xterm ]] && infocmp gnome-256color >/dev/null 2>&1; then
  TERM=gnome-256color
elif infocmp xterm-256color >/dev/null 2>&1; then
  case "$TERM" in
  'xterm') TERM=xterm-256color ;;
  'screen') TERM=screen-256color ;;
  'Eterm') TERM=Eterm-256color ;;
  esac
fi
export TERM

if tput setaf 1 &>/dev/null; then
  tput sgr0
  if [[ $(tput colors) -ge 256 ]] 2>/dev/null; then
    base03=$(tput setaf 234)
    base02=$(tput setaf 235)
    base01=$(tput setaf 240)
    base00=$(tput setaf 241)
    base0=$(tput setaf 244)
    base1=$(tput setaf 245)
    base2=$(tput setaf 254)
    base3=$(tput setaf 230)
    yellow=$(tput setaf 136)
    orange=$(tput setaf 166)
    red=$(tput setaf 160)
    magenta=$(tput setaf 125)
    violet=$(tput setaf 61)
    blue=$(tput setaf 33)
    cyan=$(tput setaf 37)
    green=$(tput setaf 64)
  else
    base03=$(tput setaf 8)
    base02=$(tput setaf 0)
    base01=$(tput setaf 10)
    base00=$(tput setaf 11)
    base0=$(tput setaf 12)
    base1=$(tput setaf 14)
    base2=$(tput setaf 7)
    base3=$(tput setaf 15)
    yellow=$(tput setaf 3)
    orange=$(tput setaf 9)
    red=$(tput setaf 1)
    magenta=$(tput setaf 5)
    violet=$(tput setaf 13)
    blue=$(tput setaf 4)
    cyan=$(tput setaf 6)
    green=$(tput setaf 2)
  fi
  bold=$(tput bold)
  reset=$(tput sgr0)
else
  bold=$(echo -n -e '\033[01m')
  reset=$(echo -n -e '\033[0m')

  yellow=$(echo -n -e '\033[1;33m')
  orange=$(echo -n -e '\033[0;33m')
  red=$(echo -n -e '\033[0;31m')
  magenta=$(echo -n -e '\033[1;31m')
  violet=$(echo -n -e '\033[1;35m')
  blue=$(echo -n -e '\033[0;34m')
  cyan=$(echo -n -e '\033[0;36m')
  green=$(echo -n -e '\033[0;32m')
fi

# Highlight the user name when logged in as root.
if [[ "${USER}" == "root" ]]; then
  username_color="${magenta}"
else
  username_color="${blue}"
fi

# Highlight the hostname when connected via SSH.
if [[ "${SSH_TTY}" ]]; then
  hostname_color="${red}"
else
  hostname_color="${yellow}"
fi

workdir_color="${cyan}"

new_line=$'\n'

jobs_bg="${red}fg: %j$reset"

ZSH_THEME_GIT_PROMPT_PREFIX=""
ZSH_THEME_GIT_PROMPT_SUFFIX=""
ZSH_THEME_GIT_PROMPT_DIRTY=""
ZSH_THEME_GIT_PROMPT_CLEAN=""
ZSH_THEME_GIT_PROMPT_UNTRACKED="?"        # if there are untracked files
ZSH_THEME_GIT_PROMPT_MODIFIED="!"         # if there are stashed changes
ZSH_THEME_GIT_PROMPT_ADDED="+"            # if there are added files
ZSH_THEME_GIT_PROMPT_STASHED="$"          # if there are stashed changes
ZSH_THEME_GIT_PROMPT_EQUAL_REMOTE="="     # if local repo is equal to remote repo (in sync)
ZSH_THEME_GIT_PROMPT_AHEAD_REMOTE=">"     # if local repo is ahead remote repo
ZSH_THEME_GIT_PROMPT_BEHIND_REMOTE="<"    # if local repo is behind remote repo
ZSH_THEME_GIT_PROMPT_DIVERGED_REMOTE="<>" # if local repo is diverged

function prompt_git() {
  local s=''
  local branchName=''

  # Check if the current directory is in a Git repository.
  if [ "$(
    git rev-parse --is-inside-work-tree &>/dev/null
    echo "${?}"
  )" == '0' ]; then

    # check if the current directory is in .git before running git checks
    if [ "$(git rev-parse --is-inside-git-dir 2>/dev/null)" == 'false' ]; then

      # Ensure the index is up to date.
      git update-index --really-refresh -q &>/dev/null

      # Check for stashed files.
      if git rev-parse --verify refs/stash &>/dev/null; then
        s+="${ZSH_THEME_GIT_PROMPT_STASHED}"
      fi

      # Check for unstaged changes.
      if ! git diff-files --quiet --ignore-submodules --; then
        s+="${ZSH_THEME_GIT_PROMPT_MODIFIED}"
      fi

      # Check for uncommitted changes in the index.
      if ! git diff --quiet --ignore-submodules --cached; then
        s+="${ZSH_THEME_GIT_PROMPT_ADDED}"
      fi

      # Check for untracked files.
      if [ -n "$(git ls-files --others --exclude-standard)" ]; then
        s+="${ZSH_THEME_GIT_PROMPT_UNTRACKED}"
      fi
    fi

    # Get the short symbolic ref.
    # If HEAD isnâ€™t a symbolic ref, get the short SHA for the latest commit
    # Otherwise, just give up.
    branchName="$(git symbolic-ref --quiet --short HEAD 2>/dev/null ||
      git rev-parse --short HEAD 2>/dev/null ||
      echo '(unknown)')"

    [ -n "${s}" ] && s=" [${s}]"

    echo -e "${1}${branchName}${2}${s}"
  else
    return
  fi
}

if [[ "$(basename "$0")" == 'bash' ]] || [[ -n "$BASH" ]]; then
  username_placeholder="\u"
  hostname_placeholder="\h"
  workdir_placeholder="\w"
  prompt_char="\$"
elif [[ "$(basename "$SHELL")" == 'zsh' ]]; then
  username_placeholder="%n"
  hostname_placeholder="%m"
  workdir_placeholder="%~"
  prompt_char=">"
else
  echo "failed to detect the current shell, message from ~/.prompt"
fi

if ! command -v 'git_prompt_info' &>/dev/null; then
  GIT_PROMPT="\$(prompt_git \" on ${orange}\" \"${violet}\")"
else
  GIT_PROMPT="\$(out=\$(git_prompt_info);if [[ -n \$out ]]; then printf %s\" on \${orange}\$out\${reset}\";fi)\${bold}"
  GIT_PROMPT+="\$(out=\$(git_prompt_status);if [[ -n \$out ]]; then printf %s\" \${violet}[\$out]\${reset}\";fi)\${bold}"
fi

# Set the terminal title and prompt.
PS1="${bold}"                                                  # initialize empty
PS1+="${username_color}${username_placeholder}${reset}${bold}" # the username of the current user
PS1+=" at "                                                    # at
PS1+="${hostname_color}${hostname_placeholder}${reset}${bold}" # the fully qualified domain name (FQDN) hostname
PS1+=" in "                                                    # in
PS1+="${workdir_color}${workdir_placeholder}${reset}${bold}"   # the current working directory
PS1+="${GIT_PROMPT}${reset}"                                   # git repository details
PS1+="${reset}"                                                # clear all decoration just in case
PS1+="${new_line}"                                             # new line
PS1+="${prompt_char} "                                         # initial character in the new line

PS2="${prompt_char}>  " # initial character in the second line

RPROMPT=''
